<!DOCTYPE html>
<html lang="de" id="html-lang">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One-Time-Pad Schlüssel-Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 800px; margin: 0 auto; background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .header { display: flex; justify-content: space-between; align-items: flex-start; }
        h1, h2, h3, h4 { border-bottom: 2px solid #eee; padding-bottom: 10px; color: #0056b3; margin-top: 0; }
        h4 { border-bottom: none; margin-bottom: 5px; color: #333; }
        .lang-switcher button { background: none; border: 1px solid #ccc; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px; }
        .lang-switcher button.active { background: #007bff; color: white; border-color: #007bff; }
        .tab-nav { display: flex; border-bottom: 1px solid #ccc; margin-bottom: 20px; }
        .tab-nav button { background: #e9e9e9; border: none; padding: 10px 15px; cursor: pointer; font-size: 16px; border-radius: 5px 5px 0 0; margin-right: 5px; }
        .tab-nav button.active { background: #007bff; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        label { font-weight: bold; margin-top: 15px; display: block; }
        input[type="text"], textarea { width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        textarea { min-height: 60px; resize: vertical; font-family: monospace; }
        textarea.short { min-height: 40px; }
        button.action-btn { background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 20px; width: 100%; }
        button.action-btn:hover { background-color: #0056b3; }
        .output-area, .result-area { margin-top: 20px; background-color: #f9f9f9; padding: 15px; border-radius: 4px; border: 1px solid #e1e1e1; }
        .output-key-container { position: relative; }
        .output-key { word-wrap: break-word; font-family: monospace; padding: 10px; background: #fff; border: 1px solid #ddd; margin-top: 10px; padding-right: 80px; }
        .copy-btn { position: absolute; top: 18px; right: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; }
        .copy-btn:hover { background: #5a6268; }
        .pdf-btn { background-color: #28a745; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-top: 10px; }
        .pdf-btn:hover { background-color: #218838; }
        .info, .warning, .error, .success { padding: 15px; margin-top: 15px; border-radius: 4px; }
        .info { background-color: #e7f3fe; border-left: 5px solid #2196F3; }
        .warning { background-color: #fff3cd; border-left: 5px solid #ffc107; }
        .error { background-color: #f8d7da; border-left: 5px solid #dc3545; }
        .success { background-color: #d4edda; border-left: 5px solid #28a745; }
        .disclaimer { margin-top: 25px; padding: 10px 15px; background-color: #fceeee; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24; text-align: center; }
        .hidden { display: none; }
        .optional-hints { background: #fafafa; border: 1px solid #eee; padding: 15px; border-radius: 5px; margin-top: 20px; }
    </style>
</head>
<body>

    <div class="container">
        <div class="header">
            <h1 data-translate-key="mainTitle">One-Time-Pad Schlüssel-Generator</h1>
            <div class="lang-switcher">
                <button id="lang-de" class="active" onclick="setLanguage('de')">DE</button>
                <button id="lang-en" onclick="setLanguage('en')">EN</button>
            </div>
        </div>
        <p data-translate-key="intro">Dieses Werkzeug teilt ein Geheimnis sicher in zwei Schlüssel nach dem One-Time-Pad-Prinzip. Bewahren Sie die beiden erzeugten Schlüssel an <strong>physisch getrennten Orten</strong> auf.</p>

        <div class="tab-nav">
            <button id="tab-encrypt-btn" class="active" onclick="switchTab('encrypt')" data-translate-key="tabEncrypt">Verschlüsseln</button>
            <button id="tab-decrypt-btn" onclick="switchTab('decrypt')" data-translate-key="tabDecrypt">Entschlüsseln</button>
        </div>

        <div id="encrypt" class="tab-content active">
            <h2 data-translate-key="encryptTitle">Neues Geheimnis aufteilen</h2>
            
            <label for="secret-name" data-translate-key="labelSecretName">Name des Geheimnisses:</label>
            <input type="text" id="secret-name" data-translate-key-placeholder="placeholderSecretName">

            <label for="secret-data" data-translate-key="labelSecret">Das Geheimnis:</label>
            <select id="input-type" style="padding: 8px; margin-top: 5px;">
                <option value="text" data-translate-key="inputTypeText">Text (UTF-8)</option>
                <option value="hex" data-translate-key="inputTypeHex">Hexadezimal</option>
            </select>
            <textarea id="secret-data" data-translate-key-placeholder="placeholderSecretData"></textarea>

            <div class="optional-hints">
                 <h3 data-translate-key="hintsTitle">Optionale Hinweise für PDFs</h3>
                 <label for="pair-hint" data-translate-key="labelPairHint">Allgemeiner Hinweis (für beide PDFs):</label>
                 <textarea id="pair-hint" class="short" data-translate-key-placeholder="placeholderPairHint"></textarea>

                 <label for="key1-hint" data-translate-key="labelKey1Hint">Hinweis nur für Schlüssel 1:</label>
                 <textarea id="key1-hint" class="short" data-translate-key-placeholder="placeholderKey1Hint"></textarea>

                 <label for="key2-hint" data-translate-key="labelKey2Hint">Hinweis nur für Schlüssel 2:</label>
                 <textarea id="key2-hint" class="short" data-translate-key-placeholder="placeholderKey2Hint"></textarea>
            </div>

            <label for="manual-input" data-translate-key="labelManualInput">Manuelle Eingabe für Salt & Seed (optional):</label>
            <input type="text" id="manual-input" data-translate-key-placeholder="placeholderManualInput">
            <div class="info" data-translate-key="infoManualInput">
                <strong>Hinweis:</strong> Nur für reproduzierbare Tests und <strong>nur bei kurzen Geheimnissen (&lt; 16 Bytes)</strong> wirksam. Format: 32 Hex-Zeichen für den Salt, gefolgt von Hex-Zeichen für den Seed.
            </div>

            <button class="action-btn" onclick="encrypt()" data-translate-key="btnGenerate">Schlüsselpaar erzeugen</button>

            <div id="encrypt-output" class="output-area hidden">
                <h3 data-translate-key="outputTitle">Erzeugtes Schlüsselpaar</h3>
                <div class="success" data-translate-key="successVerification">
                    ✔️ Selbst-Test erfolgreich. Die Schlüssel sind gültig und können verwendet werden.
                </div>
                <div class="warning" data-translate-key="warningSaveKeys">
                    <strong>Wichtig:</strong> Erzeugen Sie jetzt die PDFs oder kopieren Sie die Schlüssel. Nach dem Verlassen der Seite sind diese Daten unwiderruflich verloren.
                </div>
                
                <div id="key1-output">
                    <h4>Schlüssel 1</h4>
                    <div class="output-key-container">
                        <div id="key1-string" class="output-key"></div>
                        <button class="copy-btn" onclick="copyKey('key1-string', this)" data-translate-key="btnCopy">Kopieren</button>
                    </div>
                    <button class="pdf-btn" onclick="generatePdf(1)" data-translate-key="btnPdf1">PDF für Schlüssel 1 herunterladen</button>
                </div>

                <hr style="margin: 20px 0;">

                <div id="key2-output">
                    <h4>Schlüssel 2</h4>
                     <div class="output-key-container">
                        <div id="key2-string" class="output-key"></div>
                        <button class="copy-btn" onclick="copyKey('key2-string', this)" data-translate-key="btnCopy">Kopieren</button>
                    </div>
                    <button class="pdf-btn" onclick="generatePdf(2)" data-translate-key="btnPdf2">PDF für Schlüssel 2 herunterladen</button>
                </div>
            </div>
        </div>

        <div id="decrypt" class="tab-content">
            <h2 data-translate-key="decryptTitle">Geheimnis wiederherstellen</h2>
            <p data-translate-key="decryptIntro">Geben Sie die beiden zusammengehörigen Schlüssel ein, um das ursprüngliche Geheimnis zu rekonstruieren.</p>

            <label for="key-a" data-translate-key="labelKeyA">Schlüssel A:</label>
            <textarea id="key-a" data-translate-key-placeholder="placeholderKeyA"></textarea>

            <label for="key-b" data-translate-key="labelKeyB">Schlüssel B:</label>
            <textarea id="key-b" data-translate-key-placeholder="placeholderKeyB"></textarea>

            <button class="action-btn" onclick="decrypt()" data-translate-key="btnDecrypt">Geheimnis entschlüsseln</button>

            <div id="decrypt-output" class="result-area hidden">
                <h3 data-translate-key="decryptResultTitle">Entschlüsselungs-Ergebnis</h3>
                <div id="decrypt-status"></div>
                <div id="decrypted-secret-area" class="hidden">
                    <label data-translate-key="labelDecryptedName">Name des Geheimnisses:</label>
                    <div id="decrypted-name" style="font-weight: bold; padding: 5px; background: #eee;"></div>
                    <label data-translate-key="labelDecryptedSecret">Wiederhergestelltes Geheimnis:</label>
                    <textarea id="decrypted-secret" readonly style="background: #e2ffe8; font-family: monospace;"></textarea>
                </div>
            </div>
        </div>

        <div class="disclaimer" data-translate-key="disclaimerText">
            <strong>Haftungsausschluss:</strong> Dies ist ein Demonstrations-Projekt für ein kryptographisches Konzept. Es wurde nicht von Sicherheitsexperten geprüft. Die Nutzung erfolgt auf eigene Gefahr. Speichern Sie niemals kritische Daten ausschließlich mit diesem Werkzeug.
        </div>
    </div>

<script>
    // --- Globale Variablen und Konfiguration ---
    const APP_VERSION = "0.1";
    const HASH_LENGTH = 8;
    const SALT_LENGTH_BYTES = 16;
    const MIN_SECURE_LENGTH_BYTES = 16;
    const SEPARATOR = ';';
    let keyDataStore = {};
    let currentLang = 'en';

    // --- Übersetzungen ---
    const translations = {
        de: {
            mainTitle: "One-Time-Pad Schlüssel-Generator",
            intro: "Dieses Werkzeug teilt ein Geheimnis sicher in zwei Schlüssel nach dem One-Time-Pad-Prinzip. Bewahren Sie die beiden erzeugten Schlüssel an <strong>physisch getrennten Orten</strong> auf.",
            tabEncrypt: "Verschlüsseln",
            tabDecrypt: "Entschlüsseln",
            encryptTitle: "Neues Geheimnis aufteilen",
            labelSecretName: "Name des Geheimnisses:",
            placeholderSecretName: "z.B. Tresor-Passwort; Master-Key; etc.",
            labelSecret: "Das Geheimnis:",
            inputTypeText: "Text",
            inputTypeHex: "Hexadezimal",
            placeholderSecretData: "Geben Sie hier das Passwort, den Schlüssel oder Hex-Daten ein.",
            hintsTitle: "Optionale Hinweise für PDFs",
            labelPairHint: "Allgemeiner Hinweis (für beide PDFs):",
            placeholderPairHint: "z.B. Dieses Geheimnis wird für die Webseite xyz.com benötigt.",
            labelKey1Hint: "Hinweis nur für Schlüssel 1:",
            placeholderKey1Hint: "z.B. Den Gegen-Schlüssel hat Person A.",
            labelKey2Hint: "Hinweis nur für Schlüssel 2:",
            placeholderKey2Hint: "z.B. Den Gegen-Schlüssel hat Person B.",
            labelManualInput: "Manuelle Eingabe für Salt & Seed (optional):",
            placeholderManualInput: "32 Hex-Zeichen für Salt + Hex-Zeichen für Seed",
            infoManualInput: "<strong>Hinweis:</strong> Nur für reproduzierbare Tests und <strong>nur bei kurzen Geheimnissen (&lt; 16 Bytes)</strong> wirksam. Format: 32 Hex-Zeichen für den Salt, gefolgt von Hex-Zeichen für den Seed.",
            btnGenerate: "Schlüsselpaar erzeugen",
            outputTitle: "Erzeugtes Schlüsselpaar",
            successVerification: "✔️ Selbst-Test erfolgreich. Die Schlüssel sind gültig und können verwendet werden.",
            warningSaveKeys: "<strong>Wichtig:</strong> Erzeugen Sie jetzt die PDFs oder kopieren Sie die Schlüssel. Nach dem Verlassen der Seite sind diese Daten unwiderruflich verloren.",
            btnCopy: "Kopieren",
            btnCopied: "Kopiert!",
            btnPdf1: "PDF für Schlüssel 1 herunterladen",
            btnPdf2: "PDF für Schlüssel 2 herunterladen",
            decryptTitle: "Geheimnis wiederherstellen",
            decryptIntro: "Geben Sie die beiden zusammengehörigen Schlüssel ein, um das ursprüngliche Geheimnis zu rekonstruieren.",
            labelKeyA: "Schlüssel A:",
            placeholderKeyA: "Geben Sie hier den ersten Schlüssel ein (aus Text oder QR-Code).",
            labelKeyB: "Schlüssel B:",
            placeholderKeyB: "Geben Sie hier den zweiten Schlüssel ein.",
            btnDecrypt: "Geheimnis entschlüsseln",
            decryptResultTitle: "Entschlüsselungs-Ergebnis",
            labelDecryptedName: "Name des Geheimnisses:",
            labelDecryptedSecret: "Wiederhergestelltes Geheimnis:",
            alertEnterName: "Bitte geben Sie einen Namen und ein Geheimnis ein.",
            alertManualInputLength: `Fehler: Die manuelle Eingabe muss mindestens ${SALT_LENGTH_BYTES * 2} Hex-Zeichen für den Salt enthalten.`,
            alertPadLength: (expected, actual) => `Fehler bei manueller Eingabe: Falsche Seed-Länge. Erwartet: ${expected} Hex-Zeichen, gefunden: ${actual}.`,
            alertGenericError: (msg) => `Ein Fehler ist aufgetreten: ${msg}`,
            errorVerificationFailed: "KRITISCHER FEHLER: Der interne Selbst-Test ist fehlgeschlagen. Die erzeugten Schlüssel sind ungültig und wurden verworfen. Bitte versuchen Sie es erneut oder verwenden Sie andere Eingabedaten.",
            errorBothKeys: "Fehler: Bitte geben Sie beide Schlüssel ein.",
            errorKeyFormat: `Fehler: Schlüssel hat ein ungültiges Format. Erwartet werden 7 oder 9 Teile, getrennt durch '${SEPARATOR}'.`,
            errorKeyPair: "Fehler: Die Schlüssel sind kein gültiges Paar (einer muss KEY1, der andere KEY2 sein).",
            errorUnsupportedVersion: (v) => `❌ Nicht unterstützte Schlüssel-Version: ${v}. Dieses Werkzeug unterstützt nur Version ${APP_VERSION}.`,
            valSuccess: "Validierung erfolgreich!",
            valVersion: (v) => `✔️ Version: ${v}`,
            valSecretName: (n) => `✔️ Name des Geheimnisses: "${n}"`,
            valConfirmationHashOK: "✔️ Bestätigungs-Hash des Geheimnisses ist korrekt.",
            valOwnHashOK: "✔️ Eigener Hash ist korrekt.",
            valPairHashOK: "✔️ Hash des Gegenstücks ist korrekt.",
            valPairIDOK: (id) => `✔️ Schlüsselpaar-ID (${id}) ist korrekt.`,
            valFail: "Validierung fehlgeschlagen! Die Schlüssel sind ungültig, manipuliert oder gehören nicht zusammen.",
            valVersionMismatch: (v1, v2) => `❌ Versions-Mismatch: ${v1} vs ${v2}`,
            valNameMismatch: (n1, n2) => `❌ Namens-Mismatch: "${n1}" vs "${n2}"`,
            valConfirmationHashFail: "❌ Bestätigungs-Hash des Geheimnisses ist FALSCH. Die Schlüssel entschlüsseln nicht zum korrekten Original.",
            valOwnHashFail: "❌ Eigener Hash ist ungültig. Der Schlüssel ist beschädigt.",
            valPairHashFail: "❌ Hash des Gegenstücks stimmt nicht überein. Die Schlüssel gehören nicht zusammen.",
            valPairIDFail: "❌ Schlüsselpaar-ID stimmt nicht überein.",
            decryptedAsHex: (hex) => `(Binärdaten, als Hex dargestellt): ${hex}`,
            pdfTitle: (pairId) => `Geheimnis-Schlüssel | Paar-ID: ${pairId}`,
            pdfForSecret: (name) => `Für Geheimnis: "${name}"`,
            pdfKeyNof2: (n) => `Dies ist Schlüssel ${n} von 2`,
            pdfLabelKeyHash: "Hash dieses Schlüssels:",
            pdfLabelPairId: "Schlüsselpaar-ID:",
            pdfLabelUserHints: "Benutzerdefinierte Hinweise",
            pdfLabelFullKey: "Vollständiger Schlüssel-String:",
            pdfInstructionsTitle: "Wichtige Sicherheitshinweise",
            pdfInstruction1: (name) => `1. Dieser Schlüssel gehört zum Geheimnis "${name}".`,
            pdfInstruction2: (otherN) => `2. Er funktioniert nur zusammen mit Schlüssel ${otherN} aus demselben Paar.`,
            pdfInstruction3: "3. BEWAHREN SIE DIESEN SCHLÜSSEL AN EINEM SICHEREN, VOM ANDEREN SCHLÜSSEL PHYSISCH GETRENNTEN ORT AUF.",
            pdfInstruction4: "   (z.B. ein Schlüssel im Safe zu Hause, der andere im Bankschließfach).",
            pdfInstruction5: "4. Zur Wiederherstellung des Geheimnisses benötigen Sie beide Schlüssel und dieses Offline-Werkzeug.",
            pdfInstruction6: "5. Machen Sie keine digitalen Kopien dieses Dokuments, es sei denn, diese sind ebenfalls sicher verschlüsselt.",
            disclaimerText: "<strong>Haftungsausschluss:</strong> Dies ist ein Demonstrations-Projekt für ein kryptographisches Konzept. Es wurde nicht von Sicherheitsexperten geprüft. Die Nutzung erfolgt auf eigene Gefahr. Speichern Sie niemals kritische Daten ausschließlich mit diesem Werkzeug."
        },
        en: {
            mainTitle: "One-Time Pad Key Generator",
            intro: "This tool securely splits a secret into two keys using the one-time pad principle. Store the two generated keys in <strong>physically separate locations</strong>.",
            tabEncrypt: "Encrypt",
            tabDecrypt: "Decrypt",
            encryptTitle: "Split a New Secret",
            labelSecretName: "Name of the secret:",
            placeholderSecretName: "e.g., Safe Password; Master Key; etc.",
            labelSecret: "The secret:",
            inputTypeText: "Text",
            inputTypeHex: "Hexadecimal",
            placeholderSecretData: "Enter the password, key, or hex data here.",
            hintsTitle: "Optional Notes for PDFs",
            labelPairHint: "General note (for both PDFs):",
            placeholderPairHint: "e.g., This secret is needed for the website xyz.com",
            labelKey1Hint: "Note for Key 1 only:",
            placeholderKey1Hint: "e.g., The counterpart key is held by person A.",
            labelKey2Hint: "Note for Key 2 only:",
            placeholderKey2Hint: "e.g., The counterpart key is held by person B.",
            labelManualInput: "Manual Input for Salt & Seed (optional):",
            placeholderManualInput: "32 hex chars for salt + hex chars for seed",
            infoManualInput: "<strong>Note:</strong> Only for reproducible tests and <strong>only effective for short secrets (&lt; 16 bytes)</strong>. Format: 32 hex characters for the salt, followed by hex characters for the seed.",
            btnGenerate: "Generate Key Pair",
            outputTitle: "Generated Key Pair",
            successVerification: "✔️ Self-test successful. The keys are valid and can be used.",
            warningSaveKeys: "<strong>Important:</strong> Generate the PDFs or copy the keys now. This data will be irretrievably lost after leaving the page.",
            btnCopy: "Copy",
            btnCopied: "Copied!",
            btnPdf1: "Download PDF for Key 1",
            btnPdf2: "Download PDF for Key 2",
            decryptTitle: "Reconstruct Secret",
            decryptIntro: "Enter the two corresponding keys to reconstruct the original secret.",
            labelKeyA: "Key A:",
            placeholderKeyA: "Enter the first key here (from text or QR code).",
            labelKeyB: "Key B:",
            placeholderKeyB: "Enter the second key here.",
            btnDecrypt: "Decrypt Secret",
            decryptResultTitle: "Decryption Result",
            labelDecryptedName: "Name of the secret:",
            labelDecryptedSecret: "Reconstructed secret:",
            alertEnterName: "Please enter a name and a secret.",
            alertManualInputLength: `Error: Manual input must contain at least ${SALT_LENGTH_BYTES * 2} hex characters for the salt.`,
            alertPadLength: (expected, actual) => `Error in manual input: Incorrect seed length. Expected: ${expected} hex characters, found: ${actual}.`,
            alertGenericError: (msg) => `An error occurred: ${msg}`,
            errorVerificationFailed: "CRITICAL ERROR: The internal self-test failed. The generated keys are invalid and have been discarded. Please try again or use different input data.",
            errorBothKeys: "Error: Please enter both keys.",
            errorKeyFormat: `Error: Key has an invalid format. Expected 7 or 9 parts separated by '${SEPARATOR}'.`,
            errorKeyPair: "Error: The keys are not a valid pair (one must be KEY1, the other KEY2).",
            errorUnsupportedVersion: (v) => `❌ Unsupported key version: ${v}. This tool only supports version ${APP_VERSION}.`,
            valSuccess: "Validation successful!",
            valVersion: (v) => `✔️ Version: ${v}`,
            valSecretName: (n) => `✔️ Secret Name: "${n}"`,
            valConfirmationHashOK: "✔️ Secret confirmation hash is correct.",
            valOwnHashOK: "✔️ Own hash is correct.",
            valPairHashOK: "✔️ Counterpart hash is correct.",
            valPairIDOK: (id) => `✔️ Key Pair ID (${id}) is correct.`,
            valFail: "Validation failed! The keys are invalid, tampered with, or do not belong together.",
            valVersionMismatch: (v1, v2) => `❌ Version Mismatch: ${v1} vs ${v2}`,
            valNameMismatch: (n1, n2) => `❌ Name Mismatch: "${n1}" vs "${n2}"`,
            valConfirmationHashFail: "❌ Secret confirmation hash is WRONG. The keys do not decrypt to the correct original secret.",
            valOwnHashFail: "❌ Own hash is invalid. The key is corrupted.",
            valPairHashFail: "❌ Counterpart hash does not match. The keys do not belong together.",
            valPairIDFail: "❌ Key Pair ID does not match.",
            decryptedAsHex: (hex) => `(Binary data, shown as hex): ${hex}`,
            pdfTitle: (pairId) => `Secret Key | Pair ID: ${pairId}`,
            pdfForSecret: (name) => `For Secret: "${name}"`,
            pdfKeyNof2: (n) => `This is Key ${n} of 2`,
            pdfLabelKeyHash: "Hash of this key:",
            pdfLabelPairId: "Key Pair ID:",
            pdfLabelUserHints: "Custom Notes",
            pdfLabelFullKey: "Full Key String:",
            pdfInstructionsTitle: "Important Security Instructions",
            pdfInstruction1: (name) => `1. This key belongs to the secret "${name}".`,
            pdfInstruction2: (otherN) => `2. It only works together with Key ${otherN} from the same pair.`,
            pdfInstruction3: "3. STORE THIS KEY IN A SECURE LOCATION, PHYSICALLY SEPARATE FROM THE OTHER KEY.",
            pdfInstruction4: "   (e.g., one key in a safe at home, the other in a bank safe deposit box).",
            pdfInstruction5: "4. To reconstruct the secret, you need both keys and this offline tool.",
            pdfInstruction6: "5. Do not make digital copies of this document unless they are also securely encrypted.",
            disclaimerText: "<strong>Disclaimer:</strong> This is a demonstration project for a cryptographic concept. It has not been audited by security experts. Use at your own risk. Never store critical data exclusively with this tool."
        }
    };

    // --- Internationalization (i18n) ---
    function setLanguage(lang) {
        currentLang = lang;
        document.getElementById('html-lang').lang = lang;
        
        document.querySelectorAll('[data-translate-key]').forEach(el => {
            const key = el.getAttribute('data-translate-key');
            if (translations[lang][key]) {
                el.innerHTML = translations[lang][key];
            }
        });
        document.querySelectorAll('[data-translate-key-placeholder]').forEach(el => {
            const key = el.getAttribute('data-translate-key-placeholder');
            if (translations[lang][key]) {
                el.placeholder = translations[lang][key];
            }
        });

        document.querySelectorAll('.lang-switcher button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`lang-${lang}`).classList.add('active');
    }

    // --- UI-Steuerung ---
    function switchTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.querySelectorAll('.tab-nav button').forEach(b => b.classList.remove('active'));
        document.getElementById(tabName).classList.add('active');
        document.getElementById(`tab-${tabName}-btn`).classList.add('active');
    }

    function copyKey(elementId, buttonElement) {
        const textToCopy = document.getElementById(elementId).textContent;
        navigator.clipboard.writeText(textToCopy).then(() => {
            const originalText = buttonElement.textContent;
            buttonElement.textContent = translations[currentLang].btnCopied;
            setTimeout(() => {
                buttonElement.textContent = originalText;
            }, 2000);
        });
    }

    // --- Hilfsfunktionen: Konvertierung und Krypto ---
    const strToU8 = (str) => new TextEncoder().encode(str);
    const u8ToStr = (u8) => new TextDecoder('utf-8', { fatal: true }).decode(u8);
    const strToBase64 = (str) => btoa(unescape(encodeURIComponent(str)));
    const base64ToStr = (b64) => decodeURIComponent(escape(atob(b64)));
    
    function hexToU8(hex) {
        if (hex.length % 2 !== 0) throw new Error("Invalid hex string.");
        const u8 = new Uint8Array(hex.length / 2);
        for (let i = 0; i < u8.length; i++) {
            u8[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return u8;
    }
    const u8ToHex = (u8) => Array.from(u8).map(b => b.toString(16).padStart(2, '0')).join('');
    const u8ToBase64 = (u8) => btoa(String.fromCharCode.apply(null, u8));
    const base64ToU8 = (b64) => new Uint8Array(atob(b64).split('').map(c => c.charCodeAt(0)));
    
    function xorU8(a, b) {
        if (a.length !== b.length) throw new Error("Arrays must have the same length for XOR.");
        const result = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
            result[i] = a[i] ^ b[i];
        }
        return result;
    }
    
    async function calculateHash(data) {
        const buffer = strToU8(data);
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = u8ToHex(new Uint8Array(hashBuffer));
        return hashHex.substring(0, HASH_LENGTH);
    }
    
    const u8Equals = (a, b) => {
        if (!a || !b || a.length !== b.length) return false;
        for(let i=0; i< a.length; i++) {
            if(a[i] !== b[i]) return false;
        }
        return true;
    }

    // --- Hauptlogik: Verschlüsseln ---
    async function encrypt() {
        const name = document.getElementById('secret-name').value.trim();
        const secretInput = document.getElementById('secret-data').value.trim();
        const inputType = document.getElementById('input-type').value;
        const manualInputHex = document.getElementById('manual-input').value.trim().replace(/\s/g, '');
        const outputDiv = document.getElementById('encrypt-output');
        outputDiv.classList.add('hidden');
        
        if (!name || !secretInput) {
            alert(translations[currentLang].alertEnterName);
            return;
        }

        try {
            // 1. Geheimnis vorbereiten
            let secretU8;
            if (inputType === 'hex') {
                secretU8 = hexToU8(secretInput.replace(/\s/g, ''));
            } else {
                secretU8 = strToU8(secretInput);
            }

            const isShortSecret = secretU8.length < MIN_SECURE_LENGTH_BYTES;
            let saltU8, padU8, confirmationHash, payload1, payload2;

            if (isShortSecret) {
                // --- LOGIK FÜR KURZE GEHEIMNISSE (MIT SALT & BESTÄTIGUNGS-HASH) ---
                if (manualInputHex) {
                    const saltHexLength = SALT_LENGTH_BYTES * 2;
                    if (manualInputHex.length < saltHexLength) { alert(translations[currentLang].alertManualInputLength); return; }
                    const saltHex = manualInputHex.substring(0, saltHexLength);
                    const padHex = manualInputHex.substring(saltHexLength);
                    if (padHex.length !== secretU8.length * 2) { alert(translations[currentLang].alertPadLength(secretU8.length * 2, padHex.length)); return; }
                    saltU8 = hexToU8(saltHex);
                    padU8 = hexToU8(padHex);
                } else {
                    saltU8 = new Uint8Array(SALT_LENGTH_BYTES);
                    crypto.getRandomValues(saltU8);
                    padU8 = new Uint8Array(secretU8.length);
                    crypto.getRandomValues(padU8);
                }
                const combinedSecretSalt = new Uint8Array(secretU8.length + saltU8.length);
                combinedSecretSalt.set(secretU8);
                combinedSecretSalt.set(saltU8, secretU8.length);
                confirmationHash = new Uint8Array(await crypto.subtle.digest('SHA-256', combinedSecretSalt));
                const xoredU8 = xorU8(secretU8, padU8);
                payload1 = [APP_VERSION, 'KEY1', strToBase64(name), u8ToBase64(saltU8), u8ToBase64(confirmationHash), u8ToBase64(padU8)].join(SEPARATOR);
                payload2 = [APP_VERSION, 'KEY2', strToBase64(name), u8ToBase64(saltU8), u8ToBase64(confirmationHash), u8ToBase64(xoredU8)].join(SEPARATOR);
            } else {
                // --- LOGIK FÜR LANGE GEHEIMNISSE (OHNE SALT) ---
                padU8 = new Uint8Array(secretU8.length);
                crypto.getRandomValues(padU8);
                const xoredU8 = xorU8(secretU8, padU8);
                payload1 = [APP_VERSION, 'KEY1', strToBase64(name), u8ToBase64(padU8)].join(SEPARATOR);
                payload2 = [APP_VERSION, 'KEY2', strToBase64(name), u8ToBase64(xoredU8)].join(SEPARATOR);
            }
            
            // Gemeinsame Logik für Hashes
            const hashP1 = await calculateHash(payload1);
            const hashP2 = await calculateHash(payload2);
            const combinedHashes = [hashP1, hashP2].sort().join('');
            const keyPairId = await calculateHash(combinedHashes);
            const key1_final = [payload1, hashP1, hashP2, keyPairId].join(SEPARATOR);
            const key2_final = [payload2, hashP2, hashP1, keyPairId].join(SEPARATOR);

            const verificationResult = await verifyKeyPair(key1_final, key2_final, secretU8);
            if (!verificationResult) {
                alert(translations[currentLang].errorVerificationFailed);
                return;
            }

            keyDataStore = {
                name: name, keyPairId: keyPairId,
                key1: { full: key1_final, ownHash: hashP1 }, key2: { full: key2_final, ownHash: hashP2 },
                pairHint: document.getElementById('pair-hint').value.trim(),
                key1Hint: document.getElementById('key1-hint').value.trim(),
                key2Hint: document.getElementById('key2-hint').value.trim(),
            };
            document.getElementById('key1-string').textContent = key1_final;
            document.getElementById('key2-string').textContent = key2_final;
            outputDiv.classList.remove('hidden');

        } catch (e) {
            alert(translations[currentLang].alertGenericError(e.message));
        }
    }

    // --- Verifizierungsfunktion ---
    async function verifyKeyPair(key1_str, key2_str, originalSecretU8) {
        try {
            const parts1 = key1_str.split(SEPARATOR);
            if (parts1.length === 9) { // Kurzes Format mit Salt
                const saltU8 = base64ToU8(parts1[3]);
                const confirmationHash_fromKey = base64ToU8(parts1[4]);
                const combinedSecretSalt = new Uint8Array(originalSecretU8.length + saltU8.length);
                combinedSecretSalt.set(originalSecretU8);
                combinedSecretSalt.set(saltU8, originalSecretU8.length);
                const confirmationHash_actual = new Uint8Array(await crypto.subtle.digest('SHA-256', combinedSecretSalt));
                if (!u8Equals(confirmationHash_fromKey, confirmationHash_actual)) return false;
            }
            // Für beide Formate: Rekonstruiere und prüfe das Geheimnis
            const k1_parts = key1_str.split(SEPARATOR);
            const k2_parts = key2_str.split(SEPARATOR);
            const padU8 = base64ToU8(k1_parts[k1_parts.length - 4]);
            const xoredU8 = base64ToU8(k2_parts[k2_parts.length - 4]);
            const reconstructedSecretU8 = xorU8(padU8, xoredU8);
            
            return u8Equals(originalSecretU8, reconstructedSecretU8);
        } catch (e) {
            return false;
        }
    }
    
    // --- Hauptlogik: Entschlüsseln ---
    async function decrypt() {
        const keyA_str = document.getElementById('key-a').value.trim();
        const keyB_str = document.getElementById('key-b').value.trim();
        const outputDiv = document.getElementById('decrypt-output');
        const statusDiv = document.getElementById('decrypt-status');
        const secretArea = document.getElementById('decrypted-secret-area');
        
        outputDiv.classList.remove('hidden');
        secretArea.classList.add('hidden');
        statusDiv.innerHTML = "";
        
        const T = translations[currentLang];

        if (!keyA_str || !keyB_str) {
            statusDiv.innerHTML = `<div class="error">${T.errorBothKeys}</div>`;
            return;
        }

        try {
            const partsA = keyA_str.split(SEPARATOR);
            const partsB = keyB_str.split(SEPARATOR);
            
            if (partsA.length !== partsB.length || ![7, 9].includes(partsA.length)) {
                 statusDiv.innerHTML = `<div class="error">${T.errorKeyFormat}</div>`;
                 return;
            }
            
            let key1_parts, key2_parts;
            if (partsA[1] === 'KEY1' && partsB[1] === 'KEY2') {
                key1_parts = partsA;
                key2_parts = partsB;
            } else if (partsA[1] === 'KEY2' && partsB[1] === 'KEY1') {
                key1_parts = partsB;
                key2_parts = partsA;
            } else {
                statusDiv.innerHTML = `<div class="error">${T.errorKeyPair}</div>`;
                return;
            }

            let validationLog = "<ul>";
            let isValid = true;
            let reconstructedSecretU8;
            const isShortFormat = key1_parts.length === 9;
            
            const payload1 = key1_parts.slice(0, key1_parts.length - 3).join(SEPARATOR);
            const payload2 = key2_parts.slice(0, key2_parts.length - 3).join(SEPARATOR);
            const ownHash1_from_K1 = key1_parts[key1_parts.length - 3];
            const pairHash2_from_K1 = key1_parts[key1_parts.length - 2];
            const pairId_from_K1 = key1_parts[key1_parts.length - 1];
            const ownHash2_from_K2 = key2_parts[key2_parts.length - 3];
            const pairHash1_from_K2 = key2_parts[key2_parts.length - 2];
            const pairId_from_K2 = key2_parts[key2_parts.length - 1];

            // 1. Grundlegende Checks (Version, App-Kompatibilität, Name)
            if (key1_parts[0] !== key2_parts[0]) {
                isValid = false;
                validationLog += `<li>${T.valVersionMismatch(key1_parts[0], key2_parts[0])}</li>`;
            } else if (key1_parts[0] !== APP_VERSION) {
                isValid = false;
                validationLog += `<li>${T.errorUnsupportedVersion(key1_parts[0])}</li>`;
            } else {
                validationLog += `<li>${T.valVersion(key1_parts[0])}</li>`;
            }
            
            if (key1_parts[2] !== key2_parts[2]) {
                isValid = false;
                validationLog += `<li>${T.valNameMismatch(base64ToStr(key1_parts[2]), base64ToStr(key2_parts[2]))}</li>`;
            } else {
                validationLog += `<li>${T.valSecretName(base64ToStr(key1_parts[2]))}</li>`;
            }

            // 2. Payload- und Paar-Hashes prüfen
            const hashP1_actual = await calculateHash(payload1);
            const hashP2_actual = await calculateHash(payload2);
            if (hashP1_actual !== ownHash1_from_K1) { isValid = false; validationLog += `<li>${T.valOwnHashFail} (Key 1)</li>`; } else { validationLog += `<li>${T.valOwnHashOK} (Key 1)</li>`; }
            if (hashP2_actual !== ownHash2_from_K2) { isValid = false; validationLog += `<li>${T.valOwnHashFail} (Key 2)</li>`; } else { validationLog += `<li>${T.valOwnHashOK} (Key 2)</li>`; }
            if (hashP1_actual !== pairHash1_from_K2 || hashP2_actual !== pairHash2_from_K1) { isValid = false; validationLog += `<li>${T.valPairHashFail}</li>`; } else { validationLog += `<li>${T.valPairHashOK}</li>`; }
            if (pairId_from_K1 !== pairId_from_K2) { isValid = false; validationLog += `<li>${T.valPairIDFail}</li>`; } else {
                const combinedHashes_actual = [hashP1_actual, hashP2_actual].sort().join('');
                const pairId_actual = await calculateHash(combinedHashes_actual);
                if (pairId_actual !== pairId_from_K1) { isValid = false; validationLog += `<li>${T.valPairIDFail}</li>`; } 
                else { validationLog += `<li>${T.valPairIDOK(pairId_actual)}</li>`; }
            }

            // 3. Geheimnis rekonstruieren
            const padU8 = base64ToU8(key1_parts[key1_parts.length - 4]);
            const xoredU8 = base64ToU8(key2_parts[key2_parts.length - 4]);
            reconstructedSecretU8 = xorU8(padU8, xoredU8);
            
            // 4. Finaler Check für KURZE Geheimnisse
            if (isShortFormat) {
                const saltU8 = base64ToU8(key1_parts[3]);
                const combinedReconstructed = new Uint8Array(reconstructedSecretU8.length + saltU8.length);
                combinedReconstructed.set(reconstructedSecretU8);
                combinedReconstructed.set(saltU8, reconstructedSecretU8.length);
                const confirmationHash_recalculated = new Uint8Array(await crypto.subtle.digest('SHA-256', combinedReconstructed));
                const confirmationHash_fromKey = base64ToU8(key1_parts[4]);
                if(!u8Equals(confirmationHash_recalculated, confirmationHash_fromKey)) { isValid = false; validationLog += `<li>${T.valConfirmationHashFail}</li>`; }
                else { validationLog += `<li>${T.valConfirmationHashOK}</li>`; }
            }

            validationLog += "</ul>";

            // 5. Ergebnis anzeigen
            if (isValid) {
                statusDiv.innerHTML = `<div class="success">${T.valSuccess}</div>${validationLog}`;
                let secretFinal;
                try {
                    secretFinal = u8ToStr(reconstructedSecretU8);
                } catch(e) {
                    secretFinal = T.decryptedAsHex(u8ToHex(reconstructedSecretU8));
                }
                document.getElementById('decrypted-name').textContent = base64ToStr(key1_parts[2]);
                document.getElementById('decrypted-secret').value = secretFinal;
                secretArea.classList.remove('hidden');
            } else {
                statusDiv.innerHTML = `<div class="error">${T.valFail}</div>${validationLog}`;
            }
        } catch (e) {
            statusDiv.innerHTML = `<div class="error">${T.alertGenericError(e.message)}</div>`;
        }
    }

    // --- PDF-Generierung ---
    async function generatePdf(keyNumber) {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const T = translations[currentLang];
        
        const data = (keyNumber === 1) ? keyDataStore.key1 : keyDataStore.key2;
        const specificHint = (keyNumber === 1) ? keyDataStore.key1Hint : keyDataStore.key2Hint;

        const qrCodeImage = await QRCode.toDataURL(data.full, {
            width: 256, margin: 1, errorCorrectionLevel: 'M'
        });

        doc.setFontSize(18);
        doc.text(T.pdfTitle(keyDataStore.keyPairId), 105, 15, null, null, 'center');
        
        doc.setFontSize(14);
        doc.text(T.pdfForSecret(keyDataStore.name), 20, 30);
        doc.text(T.pdfKeyNof2(keyNumber), 20, 38);

        doc.addImage(qrCodeImage, 'PNG', 20, 45, 60, 60);

        doc.setFontSize(10);
        doc.text(T.pdfLabelKeyHash, 90, 50);
        doc.setFont("courier", "bold");
        doc.text(data.ownHash, 90, 56);
        
        doc.setFont("helvetica", "normal");
        doc.text(T.pdfLabelPairId, 90, 64);
        doc.setFont("courier", "bold");
        doc.text(keyDataStore.keyPairId, 90, 70);
        
        let currentY = 80;
        if(keyDataStore.pairHint || specificHint) {
            doc.setFontSize(11);
            doc.setFont("helvetica", "bold");
            doc.text(T.pdfLabelUserHints, 90, currentY);
            currentY += 6;
            doc.setFontSize(10);
            doc.setFont("helvetica", "normal");
            
            let hints = [];
            if(keyDataStore.pairHint) hints.push(keyDataStore.pairHint);
            if(specificHint) hints.push(specificHint);

            const hintText = doc.splitTextToSize(hints.join('\n\n'), 100);
            doc.text(hintText, 90, currentY);
        }

        doc.setFontSize(12);
        doc.setFont("helvetica", "normal");
        doc.text(T.pdfLabelFullKey, 20, 115);
        
        doc.setFont("courier", "normal");
        doc.setFontSize(8);
        doc.text(data.full, 20, 122, { maxWidth: 175 });
        
        doc.setLineWidth(0.5);
        doc.line(15, 155, 195, 155);

        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.text(T.pdfInstructionsTitle, 105, 163, null, null, 'center');

        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        const instructions = [
            T.pdfInstruction1(keyDataStore.name),
            T.pdfInstruction2((keyNumber === 1) ? 2 : 1),
            T.pdfInstruction3,
            T.pdfInstruction4,
            T.pdfInstruction5,
            T.pdfInstruction6
        ];
        doc.text(instructions, 20, 172, { maxWidth: 175 });

        doc.save(`Secret_${keyDataStore.name.replace(/[^a-zA-Z0-9]/g, '_')}_Key_${keyNumber}.pdf`);
    }
    
    document.addEventListener('DOMContentLoaded', () => { setLanguage('en'); });

</script>

</body>
</html>
